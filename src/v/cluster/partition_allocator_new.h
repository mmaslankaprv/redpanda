/*
 * Copyright 2020 Vectorized, Inc.
 *
 * Use of this software is governed by the Business Source License
 * included in the file licenses/BSL.md
 *
 * As of the Change Date specified in that file, in accordance with
 * the Business Source License, use of this software will be governed
 * by the Apache License, Version 2.0
 */

#pragma once

#include "cluster/errc.h"
#include "cluster/logger.h"
#include "cluster/types.h"
#include "model/fundamental.h"
#include "model/metadata.h"
#include "raft/types.h"
#include "vassert.h"

#include <absl/container/node_hash_map.h>

namespace cluster {
class allocation_state;

/**
 * Custom partition allocation
 */
struct custom_allocation {
    model::partition_id id;
    std::vector<model::node_id> nodes;
    friend std::ostream& operator<<(std::ostream&, const custom_allocation&);
};
/**
 * Configuration used to request partition allocation, custom allactions have
 * priority over automatically allocated partition. Allocation strategy should
 * return assignment fo all requested partitions or an error.
 */
struct allocation_configuration {
    int16_t replication_factor;
    int32_t partition_count;
    std::vector<custom_allocation> custom_allocations;
    friend std::ostream&
    operator<<(std::ostream&, const allocation_configuration&);
};
/**
 * Allocation node represent a node where partitions may be allocated
 */
class allocation_node {
public:
    static constexpr const uint32_t core0_extra_weight = 2;
    // TODO make configurable
    static constexpr const uint32_t max_allocations_per_core = 7000;

    allocation_node(
      model::node_id, uint32_t, absl::node_hash_map<ss::sstring, ss::sstring>);

    allocation_node(allocation_node&& o) noexcept = default;
    allocation_node& operator=(allocation_node&&) = delete;
    allocation_node(const allocation_node&) = delete;
    allocation_node& operator=(const allocation_node&) = delete;
    ~allocation_node() = default;

    uint32_t cpus() const { return _weights.size(); }
    model::node_id id() const { return _id; }

    uint32_t partition_capacity() const {
        // there might be a situation when node is over assigned, this state is
        // transient and it may be caused by holding allocation units while
        // state is being updated
        return _max_capacity - std::min(_allocated_partitions, _max_capacity);
    }

    uint32_t allocated_partitions() const { return _allocated_partitions; }

    void decommission() { _decommissioned = true; }
    void recommission() { _decommissioned = false; }
    bool is_decommissioned() const { return _decommissioned; }
    bool empty() const { return _allocated_partitions == 0; }
    bool is_full() const { return _allocated_partitions >= _max_capacity; }

    uint32_t allocate();

private:
    friend allocation_state;

    void deallocate(uint32_t core);
    void allocate(uint32_t core);
    const absl::node_hash_map<ss::sstring, ss::sstring>& machine_labels() const;

    model::node_id _id;
    /// each index is a CPU. A weight is roughly the number of assignments
    std::vector<uint32_t> _weights;
    const uint32_t _max_capacity;
    uint32_t _allocated_partitions{0};
    /// generated by `rpk` usually in /etc/redpanda/machine_labels.json
    absl::node_hash_map<ss::sstring, ss::sstring> _machine_labels;
    bool _decommissioned;

    friend std::ostream& operator<<(std::ostream&, const allocation_node&);
};

/**
 * Partition allocator state
 */
class allocation_state {
public:
    using node_t = allocation_node;
    using node_ptr = std::unique_ptr<node_t>;
    using underlying_t = absl::node_hash_map<model::node_id, node_ptr>;

    void deallocate(const model::broker_shard&);
    void rollback(const std::vector<partition_assignment>& pa);
    void rollback(const std::vector<model::broker_shard>& v);

    void register_node(node_ptr);
    void unregister_node(model::node_id);
    void decommission_node(model::node_id);
    void recommission_node(model::node_id);

    bool is_empty(model::node_id) const;
    bool contains_node(model::node_id n) const { return _nodes.contains(n); }

    const underlying_t& allocation_nodes() const { return _nodes; }
    void apply_update(std::vector<model::broker_shard>, raft::group_id);

    int16_t available_nodes() const;

    raft::group_id last_group_id() const { return _highest_group; }

    // allocates on the node
    result<uint32_t> allocate(model::node_id id);
    raft::group_id next_group_id();

private:
    raft::group_id _highest_group{0};
    underlying_t _nodes;
};
/**
 * RAII based helper holding allocated partititions, allocation is reverted
 * after this object goes out of scope
 */
struct allocation_units {
    allocation_units(
      std::vector<partition_assignment> assignments, allocation_state* state)
      : _assignments(std::move(assignments))
      , _state(state) {}

    allocation_units& operator=(allocation_units&&) = default;
    allocation_units& operator=(const allocation_units&) = delete;
    allocation_units(const allocation_units&) = delete;
    allocation_units(allocation_units&&) = default;

    ~allocation_units() {
        for (auto& pas : _assignments) {
            for (auto& replica : pas.replicas) {
                _state->deallocate(replica);
            }
        }
    }

    const std::vector<partition_assignment>& get_assignments() {
        return _assignments;
    }

private:
    std::vector<partition_assignment> _assignments;
    // keep the pointer to make this type movable
    allocation_state* _state;
};

class allocation_strategy {
public:
    struct impl {
        virtual result<allocation_units>
        allocate_partitions(const allocation_configuration&, allocation_state&)
          = 0;
        virtual ~impl() = default;
    };
    explicit allocation_strategy(std::unique_ptr<impl> impl)
      : _impl(std::move(impl)) {}

    result<allocation_units> allocate_partitions(
      const allocation_configuration& ac, allocation_state& state) {
        return _impl->allocate_partitions(ac, state);
    }

private:
    std::unique_ptr<impl> _impl;
};

class reallocation_strategy {
public:
    struct impl {
        virtual result<allocation_units> reallocate_partitions(
          const std::vector<model::node_id>&,
          const partition_assignment&,
          allocation_state&)
          = 0;
        virtual ~impl() = default;
    };

    explicit reallocation_strategy(std::unique_ptr<impl> impl)
      : _impl(std::move(impl)) {}

    result<allocation_units> reallocate_partitions(
      const std::vector<model::node_id>& nodes_to_remove,
      const partition_assignment& current,
      allocation_state& state) {
        return _impl->reallocate_partitions(nodes_to_remove, current, state);
    }

private:
    std::unique_ptr<impl> _impl;
};

template<typename Impl, typename... Args>
allocation_strategy make_allocation_strategy(Args... args) {
    return allocation_strategy(
      std::make_unique<Impl>(std::forward<Args>(args)...));
}

template<typename Impl, typename... Args>
reallocation_strategy make_reallocation_strategy(Args... args) {
    return reallocation_strategy(
      std::make_unique<Impl>(std::forward<Args>(args)...));
}

class partition_allocator {
public:
    static constexpr ss::shard_id shard = 0;

    partition_allocator(allocation_strategy, reallocation_strategy);

    void register_node(allocation_state::node_ptr n) {
        vlog(clusterlog.debug, "registering allocation node: {}", *n);
        _state->register_node(std::move(n));
    }
    void unregister_node(model::node_id id) {
        vlog(clusterlog.debug, "removing allocation node: {}", id);
        return _state->unregister_node(id);
    };
    void decommission_node(model::node_id id) { _state->decommission_node(id); }
    void recommission_node(model::node_id id) { _state->recommission_node(id); }

    bool is_empty(model::node_id id) const { return _state->is_empty(id); }
    bool contains_node(model::node_id n) const {
        return _state->contains_node(n);
    }

    /// best effort placement.
    /// kafka/common/protocol/Errors.java does not have a way to
    /// represent failed allocation yet. Up to caller to interpret
    /// how to use a nullopt value
    result<allocation_units> allocate(const allocation_configuration& cfg) {
        vlog(clusterlog.trace, "allocation request for: {}", cfg);
        if (
          cfg.replication_factor <= 0
          || _state->available_nodes() < cfg.replication_factor) {
            return errc::topic_invalid_replication_factor;
        }
        if (unlikely(cfg.partition_count <= 0)) {
            return errc::topic_invalid_partitions;
        }
        return _allocation_strategy.allocate_partitions(cfg, *_state);
    }

    /// Realocates partition replicas, moving them away from decommissioned
    /// nodes. Replicas on nodes that were left untouched are not changed.
    ///
    /// Returns an error it reallocation is impossible
    result<allocation_units>
    reassign_decommissioned_replicas(const partition_assignment& current);

    /// best effort. Does not throw if we cannot find the old partition
    void deallocate(const std::vector<model::broker_shard>&);

    /// updates the state of allocation, it is used during recovery and
    /// when processing raft0 committed notifications
    void update_allocation_state(
      const std::vector<model::topic_metadata>&, raft::group_id);

    allocation_state& state() { return *_state; }

private:
    std::unique_ptr<allocation_state> _state;
    allocation_strategy _allocation_strategy;
    reallocation_strategy _reallocation_strategy;
};

} // namespace cluster
